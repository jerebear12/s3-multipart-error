import { booleanSelector, SelectorType } from '@aws-sdk/util-config-provider';
import { HttpRequest } from '@aws-sdk/protocol-http';
import { validate, parse } from '@aws-sdk/util-arn-parser';

var NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME = "AWS_S3_DISABLE_MULTIREGION_ACCESS_POINTS";
var NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME = "s3_disable_multiregion_access_points";
var NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS = {
    environmentVariableSelector: function (env) {
        return booleanSelector(env, NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME, SelectorType.ENV);
    },
    configFileSelector: function (profile) {
        return booleanSelector(profile, NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME, SelectorType.CONFIG);
    },
    default: false,
};

var NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
var NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
var NODE_USE_ARN_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: function (env) {
        return booleanSelector(env, NODE_USE_ARN_REGION_ENV_NAME, SelectorType.ENV);
    },
    configFileSelector: function (profile) { return booleanSelector(profile, NODE_USE_ARN_REGION_INI_NAME, SelectorType.CONFIG); },
    default: false,
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
var DOTS_PATTERN = /\.\./;
var DOT_PATTERN = /\./;
var S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
var S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\.amazonaws\.com$/;
var AWS_PARTITION_SUFFIX = "amazonaws.com";
var isBucketNameOptions = function (options) { return typeof options.bucketName === "string"; };
var isDnsCompatibleBucketName = function (bucketName) {
    return DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
};
var getRegionalSuffix = function (hostname) {
    var parts = hostname.match(S3_HOSTNAME_PATTERN);
    return [parts[4], hostname.replace(new RegExp("^".concat(parts[0])), "")];
};
var getSuffix = function (hostname) {
    return S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? ["us-east-1", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);
};
var getSuffixForArnEndpoint = function (hostname) {
    return S3_US_EAST_1_ALTNAME_PATTERN.test(hostname)
        ? [hostname.replace(".".concat(AWS_PARTITION_SUFFIX), ""), AWS_PARTITION_SUFFIX]
        : getRegionalSuffix(hostname);
};
var validateArnEndpointOptions = function (options) {
    if (options.pathStyleEndpoint) {
        throw new Error("Path-style S3 endpoint is not supported when bucket is an ARN");
    }
    if (options.accelerateEndpoint) {
        throw new Error("Accelerate endpoint is not supported when bucket is an ARN");
    }
    if (!options.tlsCompatible) {
        throw new Error("HTTPS is required when bucket is an ARN");
    }
};
var validateService = function (service) {
    if (service !== "s3" && service !== "s3-outposts" && service !== "s3-object-lambda") {
        throw new Error("Expect 's3' or 's3-outposts' or 's3-object-lambda' in ARN service component");
    }
};
var validateS3Service = function (service) {
    if (service !== "s3") {
        throw new Error("Expect 's3' in Accesspoint ARN service component");
    }
};
var validateOutpostService = function (service) {
    if (service !== "s3-outposts") {
        throw new Error("Expect 's3-posts' in Outpost ARN service component");
    }
};
var validatePartition = function (partition, options) {
    if (partition !== options.clientPartition) {
        throw new Error("Partition in ARN is incompatible, got \"".concat(partition, "\" but expected \"").concat(options.clientPartition, "\""));
    }
};
var validateRegion = function (region, options) {
    if (region === "") {
        throw new Error("ARN region is empty");
    }
    if (options.useFipsEndpoint) {
        if (!options.allowFipsRegion) {
            throw new Error("FIPS region is not supported");
        }
        else if (!isEqualRegions(region, options.clientRegion)) {
            throw new Error("Client FIPS region ".concat(options.clientRegion, " doesn't match region ").concat(region, " in ARN"));
        }
    }
    if (!options.useArnRegion &&
        !isEqualRegions(region, options.clientRegion || "") &&
        !isEqualRegions(region, options.clientSigningRegion || "")) {
        throw new Error("Region in ARN is incompatible, got ".concat(region, " but expected ").concat(options.clientRegion));
    }
};
var validateRegionalClient = function (region) {
    if (["s3-external-1", "aws-global"].includes(region)) {
        throw new Error("Client region ".concat(region, " is not regional"));
    }
};
var isEqualRegions = function (regionA, regionB) { return regionA === regionB; };
var validateAccountId = function (accountId) {
    if (!/[0-9]{12}/.exec(accountId)) {
        throw new Error("Access point ARN accountID does not match regex '[0-9]{12}'");
    }
};
var validateDNSHostLabel = function (label, options) {
    if (options === void 0) { options = { tlsCompatible: true }; }
    if (label.length >= 64 ||
        !/^[a-z0-9][a-z0-9.-]*[a-z0-9]$/.test(label) ||
        /(\d+\.){3}\d+/.test(label) ||
        /[.-]{2}/.test(label) ||
        ((options === null || options === void 0 ? void 0 : options.tlsCompatible) && DOT_PATTERN.test(label))) {
        throw new Error("Invalid DNS label ".concat(label));
    }
};
var validateCustomEndpoint = function (options) {
    if (options.isCustomEndpoint) {
        if (options.dualstackEndpoint)
            throw new Error("Dualstack endpoint is not supported with custom endpoint");
        if (options.accelerateEndpoint)
            throw new Error("Accelerate endpoint is not supported with custom endpoint");
    }
};
var getArnResources = function (resource) {
    var delimiter = resource.includes(":") ? ":" : "/";
    var _a = __read(resource.split(delimiter)), resourceType = _a[0], rest = _a.slice(1);
    if (resourceType === "accesspoint") {
        if (rest.length !== 1 || rest[0] === "") {
            throw new Error("Access Point ARN should have one resource accesspoint".concat(delimiter, "{accesspointname}"));
        }
        return { accesspointName: rest[0] };
    }
    else if (resourceType === "outpost") {
        if (!rest[0] || rest[1] !== "accesspoint" || !rest[2] || rest.length !== 3) {
            throw new Error("Outpost ARN should have resource outpost".concat(delimiter, "{outpostId}").concat(delimiter, "accesspoint").concat(delimiter, "{accesspointName}"));
        }
        var _b = __read(rest, 3), outpostId = _b[0], _1 = _b[1], accesspointName = _b[2];
        return { outpostId: outpostId, accesspointName: accesspointName };
    }
    else {
        throw new Error("ARN resource should begin with 'accesspoint".concat(delimiter, "' or 'outpost").concat(delimiter, "'"));
    }
};
var validateNoDualstack = function (dualstackEndpoint) {
    if (dualstackEndpoint)
        throw new Error("Dualstack endpoint is not supported with Outpost or Multi-region Access Point ARN.");
};
var validateNoFIPS = function (useFipsEndpoint) {
    if (useFipsEndpoint)
        throw new Error("FIPS region is not supported with Outpost.");
};
var validateMrapAlias = function (name) {
    try {
        name.split(".").forEach(function (label) {
            validateDNSHostLabel(label);
        });
    }
    catch (e) {
        throw new Error("\"".concat(name, "\" is not a DNS compatible name."));
    }
};

var bucketHostname = function (options) {
    validateCustomEndpoint(options);
    return isBucketNameOptions(options)
        ?
            getEndpointFromBucketName(options)
        :
            getEndpointFromArn(options);
};
var getEndpointFromBucketName = function (_a) {
    var _b = _a.accelerateEndpoint, accelerateEndpoint = _b === void 0 ? false : _b, region = _a.clientRegion, baseHostname = _a.baseHostname, bucketName = _a.bucketName, _c = _a.dualstackEndpoint, dualstackEndpoint = _c === void 0 ? false : _c, _d = _a.fipsEndpoint, _e = _a.pathStyleEndpoint, pathStyleEndpoint = _e === void 0 ? false : _e, _f = _a.tlsCompatible, tlsCompatible = _f === void 0 ? true : _f, _g = _a.isCustomEndpoint, isCustomEndpoint = _g === void 0 ? false : _g;
    var _h = __read(isCustomEndpoint ? [region, baseHostname] : getSuffix(baseHostname), 2), clientRegion = _h[0], hostnameSuffix = _h[1];
    if (pathStyleEndpoint || !isDnsCompatibleBucketName(bucketName) || (tlsCompatible && DOT_PATTERN.test(bucketName))) {
        return {
            bucketEndpoint: false,
            hostname: dualstackEndpoint ? "s3.dualstack.".concat(clientRegion, ".").concat(hostnameSuffix) : baseHostname,
        };
    }
    if (accelerateEndpoint) {
        baseHostname = "s3-accelerate".concat(dualstackEndpoint ? ".dualstack" : "", ".").concat(hostnameSuffix);
    }
    else if (dualstackEndpoint) {
        baseHostname = "s3.dualstack.".concat(clientRegion, ".").concat(hostnameSuffix);
    }
    return {
        bucketEndpoint: true,
        hostname: "".concat(bucketName, ".").concat(baseHostname),
    };
};
var getEndpointFromArn = function (options) {
    var isCustomEndpoint = options.isCustomEndpoint, baseHostname = options.baseHostname, clientRegion = options.clientRegion;
    var hostnameSuffix = isCustomEndpoint ? baseHostname : getSuffixForArnEndpoint(baseHostname)[1];
    var pathStyleEndpoint = options.pathStyleEndpoint, _a = options.accelerateEndpoint, accelerateEndpoint = _a === void 0 ? false : _a, _b = options.fipsEndpoint, _c = options.tlsCompatible, tlsCompatible = _c === void 0 ? true : _c, bucketName = options.bucketName, _d = options.clientPartition, clientPartition = _d === void 0 ? "aws" : _d;
    validateArnEndpointOptions({ pathStyleEndpoint: pathStyleEndpoint, accelerateEndpoint: accelerateEndpoint, tlsCompatible: tlsCompatible });
    var service = bucketName.service, partition = bucketName.partition, accountId = bucketName.accountId, region = bucketName.region, resource = bucketName.resource;
    validateService(service);
    validatePartition(partition, { clientPartition: clientPartition });
    validateAccountId(accountId);
    var _e = getArnResources(resource), accesspointName = _e.accesspointName, outpostId = _e.outpostId;
    if (service === "s3-object-lambda") {
        return getEndpointFromObjectLambdaArn(__assign(__assign({}, options), { tlsCompatible: tlsCompatible, bucketName: bucketName, accesspointName: accesspointName, hostnameSuffix: hostnameSuffix }));
    }
    if (region === "") {
        return getEndpointFromMRAPArn(__assign(__assign({}, options), { clientRegion: clientRegion, mrapAlias: accesspointName, hostnameSuffix: hostnameSuffix }));
    }
    if (outpostId) {
        return getEndpointFromOutpostArn(__assign(__assign({}, options), { clientRegion: clientRegion, outpostId: outpostId, accesspointName: accesspointName, hostnameSuffix: hostnameSuffix }));
    }
    return getEndpointFromAccessPointArn(__assign(__assign({}, options), { clientRegion: clientRegion, accesspointName: accesspointName, hostnameSuffix: hostnameSuffix }));
};
var getEndpointFromObjectLambdaArn = function (_a) {
    var _b = _a.dualstackEndpoint, dualstackEndpoint = _b === void 0 ? false : _b, _c = _a.fipsEndpoint, fipsEndpoint = _c === void 0 ? false : _c, _d = _a.tlsCompatible, tlsCompatible = _d === void 0 ? true : _d, useArnRegion = _a.useArnRegion, clientRegion = _a.clientRegion, _e = _a.clientSigningRegion, clientSigningRegion = _e === void 0 ? clientRegion : _e, accesspointName = _a.accesspointName, bucketName = _a.bucketName, hostnameSuffix = _a.hostnameSuffix;
    var accountId = bucketName.accountId, region = bucketName.region, service = bucketName.service;
    validateRegionalClient(clientRegion);
    validateRegion(region, {
        useArnRegion: useArnRegion,
        clientRegion: clientRegion,
        clientSigningRegion: clientSigningRegion,
        allowFipsRegion: true,
        useFipsEndpoint: fipsEndpoint,
    });
    validateNoDualstack(dualstackEndpoint);
    var DNSHostLabel = "".concat(accesspointName, "-").concat(accountId);
    validateDNSHostLabel(DNSHostLabel, { tlsCompatible: tlsCompatible });
    var endpointRegion = useArnRegion ? region : clientRegion;
    var signingRegion = useArnRegion ? region : clientSigningRegion;
    return {
        bucketEndpoint: true,
        hostname: "".concat(DNSHostLabel, ".").concat(service).concat(fipsEndpoint ? "-fips" : "", ".").concat(endpointRegion, ".").concat(hostnameSuffix),
        signingRegion: signingRegion,
        signingService: service,
    };
};
var getEndpointFromMRAPArn = function (_a) {
    var disableMultiregionAccessPoints = _a.disableMultiregionAccessPoints, _b = _a.dualstackEndpoint, dualstackEndpoint = _b === void 0 ? false : _b, isCustomEndpoint = _a.isCustomEndpoint, mrapAlias = _a.mrapAlias, hostnameSuffix = _a.hostnameSuffix;
    if (disableMultiregionAccessPoints === true) {
        throw new Error("SDK is attempting to use a MRAP ARN. Please enable to feature.");
    }
    validateMrapAlias(mrapAlias);
    validateNoDualstack(dualstackEndpoint);
    return {
        bucketEndpoint: true,
        hostname: "".concat(mrapAlias).concat(isCustomEndpoint ? "" : ".accesspoint.s3-global", ".").concat(hostnameSuffix),
        signingRegion: "*",
    };
};
var getEndpointFromOutpostArn = function (_a) {
    var useArnRegion = _a.useArnRegion, clientRegion = _a.clientRegion, _b = _a.clientSigningRegion, clientSigningRegion = _b === void 0 ? clientRegion : _b, bucketName = _a.bucketName, outpostId = _a.outpostId, _c = _a.dualstackEndpoint, dualstackEndpoint = _c === void 0 ? false : _c, _d = _a.fipsEndpoint, fipsEndpoint = _d === void 0 ? false : _d, _e = _a.tlsCompatible, tlsCompatible = _e === void 0 ? true : _e, accesspointName = _a.accesspointName, isCustomEndpoint = _a.isCustomEndpoint, hostnameSuffix = _a.hostnameSuffix;
    validateRegionalClient(clientRegion);
    validateRegion(bucketName.region, { useArnRegion: useArnRegion, clientRegion: clientRegion, clientSigningRegion: clientSigningRegion, useFipsEndpoint: fipsEndpoint });
    var DNSHostLabel = "".concat(accesspointName, "-").concat(bucketName.accountId);
    validateDNSHostLabel(DNSHostLabel, { tlsCompatible: tlsCompatible });
    var endpointRegion = useArnRegion ? bucketName.region : clientRegion;
    var signingRegion = useArnRegion ? bucketName.region : clientSigningRegion;
    validateOutpostService(bucketName.service);
    validateDNSHostLabel(outpostId, { tlsCompatible: tlsCompatible });
    validateNoDualstack(dualstackEndpoint);
    validateNoFIPS(fipsEndpoint);
    var hostnamePrefix = "".concat(DNSHostLabel, ".").concat(outpostId);
    return {
        bucketEndpoint: true,
        hostname: "".concat(hostnamePrefix).concat(isCustomEndpoint ? "" : ".s3-outposts.".concat(endpointRegion), ".").concat(hostnameSuffix),
        signingRegion: signingRegion,
        signingService: "s3-outposts",
    };
};
var getEndpointFromAccessPointArn = function (_a) {
    var useArnRegion = _a.useArnRegion, clientRegion = _a.clientRegion, _b = _a.clientSigningRegion, clientSigningRegion = _b === void 0 ? clientRegion : _b, bucketName = _a.bucketName, _c = _a.dualstackEndpoint, dualstackEndpoint = _c === void 0 ? false : _c, _d = _a.fipsEndpoint, fipsEndpoint = _d === void 0 ? false : _d, _e = _a.tlsCompatible, tlsCompatible = _e === void 0 ? true : _e, accesspointName = _a.accesspointName, isCustomEndpoint = _a.isCustomEndpoint, hostnameSuffix = _a.hostnameSuffix;
    validateRegionalClient(clientRegion);
    validateRegion(bucketName.region, {
        useArnRegion: useArnRegion,
        clientRegion: clientRegion,
        clientSigningRegion: clientSigningRegion,
        allowFipsRegion: true,
        useFipsEndpoint: fipsEndpoint,
    });
    var hostnamePrefix = "".concat(accesspointName, "-").concat(bucketName.accountId);
    validateDNSHostLabel(hostnamePrefix, { tlsCompatible: tlsCompatible });
    var endpointRegion = useArnRegion ? bucketName.region : clientRegion;
    var signingRegion = useArnRegion ? bucketName.region : clientSigningRegion;
    validateS3Service(bucketName.service);
    return {
        bucketEndpoint: true,
        hostname: "".concat(hostnamePrefix).concat(isCustomEndpoint
            ? ""
            : ".s3-accesspoint".concat(fipsEndpoint ? "-fips" : "").concat(dualstackEndpoint ? ".dualstack" : "", ".").concat(endpointRegion), ".").concat(hostnameSuffix),
        signingRegion: signingRegion,
    };
};

var bucketEndpointMiddleware = function (options) {
    return function (next, context) {
        return function (args) { return __awaiter(void 0, void 0, void 0, function () {
            var bucketName, replaceBucketInPath, request, bucketArn, clientRegion, useDualstackEndpoint, useFipsEndpoint, _a, partition, _b, signingRegion, useArnRegion, _c, hostname, bucketEndpoint, modifiedSigningRegion, signingService, _d, clientRegion, dualstackEndpoint, fipsEndpoint, _e, hostname, bucketEndpoint;
            var _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        bucketName = args.input.Bucket;
                        replaceBucketInPath = options.bucketEndpoint;
                        request = args.request;
                        if (!HttpRequest.isInstance(request)) return [3, 13];
                        if (!options.bucketEndpoint) return [3, 1];
                        request.hostname = bucketName;
                        return [3, 12];
                    case 1:
                        if (!validate(bucketName)) return [3, 8];
                        bucketArn = parse(bucketName);
                        return [4, options.region()];
                    case 2:
                        clientRegion = _g.sent();
                        return [4, options.useDualstackEndpoint()];
                    case 3:
                        useDualstackEndpoint = _g.sent();
                        return [4, options.useFipsEndpoint()];
                    case 4:
                        useFipsEndpoint = _g.sent();
                        return [4, options.regionInfoProvider(clientRegion, { useDualstackEndpoint: useDualstackEndpoint, useFipsEndpoint: useFipsEndpoint })];
                    case 5:
                        _a = (_g.sent()) || {}, partition = _a.partition, _b = _a.signingRegion, signingRegion = _b === void 0 ? clientRegion : _b;
                        return [4, options.useArnRegion()];
                    case 6:
                        useArnRegion = _g.sent();
                        _d = bucketHostname;
                        _f = {
                            bucketName: bucketArn,
                            baseHostname: request.hostname,
                            accelerateEndpoint: options.useAccelerateEndpoint,
                            dualstackEndpoint: useDualstackEndpoint,
                            fipsEndpoint: useFipsEndpoint,
                            pathStyleEndpoint: options.forcePathStyle,
                            tlsCompatible: request.protocol === "https:",
                            useArnRegion: useArnRegion,
                            clientPartition: partition,
                            clientSigningRegion: signingRegion,
                            clientRegion: clientRegion,
                            isCustomEndpoint: options.isCustomEndpoint
                        };
                        return [4, options.disableMultiregionAccessPoints()];
                    case 7:
                        _c = _d.apply(void 0, [(_f.disableMultiregionAccessPoints = _g.sent(),
                                _f)]), hostname = _c.hostname, bucketEndpoint = _c.bucketEndpoint, modifiedSigningRegion = _c.signingRegion, signingService = _c.signingService;
                        if (modifiedSigningRegion && modifiedSigningRegion !== signingRegion) {
                            context["signing_region"] = modifiedSigningRegion;
                        }
                        if (signingService && signingService !== "s3") {
                            context["signing_service"] = signingService;
                        }
                        request.hostname = hostname;
                        replaceBucketInPath = bucketEndpoint;
                        return [3, 12];
                    case 8: return [4, options.region()];
                    case 9:
                        clientRegion = _g.sent();
                        return [4, options.useDualstackEndpoint()];
                    case 10:
                        dualstackEndpoint = _g.sent();
                        return [4, options.useFipsEndpoint()];
                    case 11:
                        fipsEndpoint = _g.sent();
                        _e = bucketHostname({
                            bucketName: bucketName,
                            clientRegion: clientRegion,
                            baseHostname: request.hostname,
                            accelerateEndpoint: options.useAccelerateEndpoint,
                            dualstackEndpoint: dualstackEndpoint,
                            fipsEndpoint: fipsEndpoint,
                            pathStyleEndpoint: options.forcePathStyle,
                            tlsCompatible: request.protocol === "https:",
                            isCustomEndpoint: options.isCustomEndpoint,
                        }), hostname = _e.hostname, bucketEndpoint = _e.bucketEndpoint;
                        request.hostname = hostname;
                        replaceBucketInPath = bucketEndpoint;
                        _g.label = 12;
                    case 12:
                        if (replaceBucketInPath) {
                            request.path = request.path.replace(/^(\/)?[^\/]+/, "");
                            if (request.path === "") {
                                request.path = "/";
                            }
                        }
                        _g.label = 13;
                    case 13: return [2, next(__assign(__assign({}, args), { request: request }))];
                }
            });
        }); };
    };
};
var bucketEndpointMiddlewareOptions = {
    tags: ["BUCKET_ENDPOINT"],
    name: "bucketEndpointMiddleware",
    relation: "before",
    toMiddleware: "hostHeaderMiddleware",
    override: true,
};
var getBucketEndpointPlugin = function (options) { return ({
    applyToStack: function (clientStack) {
        clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
    },
}); };

function resolveBucketEndpointConfig(input) {
    var _a = input.bucketEndpoint, bucketEndpoint = _a === void 0 ? false : _a, _b = input.forcePathStyle, forcePathStyle = _b === void 0 ? false : _b, _c = input.useAccelerateEndpoint, useAccelerateEndpoint = _c === void 0 ? false : _c, _d = input.useArnRegion, useArnRegion = _d === void 0 ? false : _d, _e = input.disableMultiregionAccessPoints, disableMultiregionAccessPoints = _e === void 0 ? false : _e;
    return __assign(__assign({}, input), { bucketEndpoint: bucketEndpoint, forcePathStyle: forcePathStyle, useAccelerateEndpoint: useAccelerateEndpoint, useArnRegion: typeof useArnRegion === "function" ? useArnRegion : function () { return Promise.resolve(useArnRegion); }, disableMultiregionAccessPoints: typeof disableMultiregionAccessPoints === "function"
            ? disableMultiregionAccessPoints
            : function () { return Promise.resolve(disableMultiregionAccessPoints); } });
}

export { NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS, NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME, NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME, NODE_USE_ARN_REGION_CONFIG_OPTIONS, NODE_USE_ARN_REGION_ENV_NAME, NODE_USE_ARN_REGION_INI_NAME, bucketEndpointMiddleware, bucketEndpointMiddlewareOptions, bucketHostname, getArnResources, getBucketEndpointPlugin, getSuffixForArnEndpoint, resolveBucketEndpointConfig, validateAccountId, validateDNSHostLabel, validateNoDualstack, validateNoFIPS, validateOutpostService, validatePartition, validateRegion };
